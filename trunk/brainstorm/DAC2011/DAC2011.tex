
%% bare_conf.tex
%% V1.3
%% 2007/01/11
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.7 or later) with an IEEE conference paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_jrnl_compsoc.tex
%%*************************************************************************

% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices can trigger bugs that do  ***
% *** not appear when using other class files.                            ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



% Note that the a4paper option is mainly intended so that authors in
% countries using A4 can easily print to A4 and see how their papers will
% look in print - the typesetting of the document will not typically be
% affected with changes in paper size (but the bottom and side margins will).
% Use the testflow package mentioned above to verify correct handling of
% both paper sizes by the user's LaTeX system.
%
% Also note that the "draftcls" or "draftclsnofoot", not "draft", option
% should be used if it is desired that the figures are to be displayed in
% draft mode.
%
\documentclass[conference]{IEEEtran}

% Add the compsoc option for Computer Society conferences.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.
% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at: 
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\newtheorem{defn}{Definition}
\newtheorem{lem}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem{exmp}{Example}[section]
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later 
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )

\usepackage{enumerate}
\newcommand{\Hom}[2]{\mathit{Hom}(#1,#2)}
\newcommand{\HImg}[1]{\mathit{Hom}(#1)}
\newcommand{\seval}[3]{\mathit{seval}(#1,#2,#3)}
\newcommand{\DefinedToBe}{\stackrel{\mathit{\cdot}}{=}}
\newcommand{\terms}[1]{\mathcal{T}(#1)}
\newcommand{\tclear}{\mathcal{T}}
\newcommand{\iso}{\sim}
\newcommand{\sols}[1]{\mathit{sols}(#1)}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\newcommand{\FORMULA}{FORMULA}%\textsc{Formula}}

\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Generalized Design Space Exploration for Optimizing Embedded Software Architectures}


% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
%\author{\IEEEauthorblockN{Andrey Breslav}
%\IEEEauthorblockA{Department of Mathematics\\
%ITMO University\\
%St. Petersburg, Russia\\
%abreslav@gmail.com}
%\and
%\IEEEauthorblockN{Ethan K. Jackson}
%\IEEEauthorblockA{Research in Software Engineering\\
%Microsoft Research\\
%Redmond, WA, USA\\
%ejackson@microsoft.com}}

% conference papers do not typically use \thanks and this command
% is locked out in conference mode. If really needed, such as for
% the acknowledgment of grants, issue a \IEEEoverridecommandlockouts
% after \documentclass

% for over three affiliations, or if they all won't fit within the width
% of the page, use this alternative format:
% 
%\author{\IEEEauthorblockN{Michael Shell\IEEEauthorrefmark{1},
%Homer Simpson\IEEEauthorrefmark{2},
%James Kirk\IEEEauthorrefmark{3}, 
%Montgomery Scott\IEEEauthorrefmark{3} and
%Eldon Tyrell\IEEEauthorrefmark{4}}
%\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Electrical and Computer Engineering\\
%Georgia Institute of Technology,
%Atlanta, Georgia 30332--0250\\ Email: see http://www.michaelshell.org/contact.html}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}Twentieth Century Fox, Springfield, USA\\
%Email: homer@thesimpsons.com}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}Starfleet Academy, San Francisco, California 96678-2391\\
%Telephone: (800) 555--1212, Fax: (888) 555--1212}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}Tyrell Inc., 123 Replicant Street, Los Angeles, California 90210--4321}}




% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle


\begin{abstract}
%\boldmath
The abstract goes here.
\end{abstract}
% IEEEtran.cls defaults to using nonbold math in the Abstract.
% This preserves the distinction between vectors and scalars. However,
% if the conference you are submitting to favors bold math in the abstract,
% then you can use LaTeX's standard command \boldmath at the very start
% of the abstract to achieve this. Many IEEE journals/conferences frown on
% math in the abstract anyway.

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle

\section{Introduction}
\textit{Design space exploration} (DSE) is a technique for automatically enumerating variants of a system; efficient DSE enables automated rapid prototyping and optimization. Consequently, DSE has been heavily investigated for hardware \cite{Mariani2010,Ascia2007,Kakita2006} and software architectures \cite{}, yielding encouraging results. 

However, there is a fundamental limitation to many DSE approaches: They explore small subsets of possible architectures by varying a few system parameters. For example, a design space may be constructed by varying some details of a point design, such as the cache sizes of processors [] or the software implementations of FFTs []. We refer to such design spaces as \emph{uniform} below. More formally, a design space is uniform if every point in this space is characterized by a finite vector $X = \left(x_1, \ldots, x_n\right)$, where each \emph{degree of freedom} $x_i$ is known to belong to a set $S_i \subseteq \mathbb{R}$ of finite measure $\mu(S_i) < \infty$. The resulting design space contains a family of related point designs differing only along the predefined axes $x_i$. This restricts optimization to a narrow range of variants derived from a particular point design. 

One way to overcome this limitation is by defining design spaces with more complex constraints; the solutions to these constraints equals the design space. Recent advances in constraint solvers can be utilized to efficiently enumerate points in the design space. This approach has been explored with the FORMULA specification language \cite{Jackson2009}. Here, the design space is defined through constraints written in first-order logic extended with a fixpoint operator. The efficient \text{satisfiability modulo theories} (SMT) solver is used to enumerate solitions.

Ideally, an exploration algorithm should enumerate the points of a design space randomly with a uniform distribution; this (probabilistically) guarantees a diverse range of architectures are observed during an arbitrary run of the algorithm. Unfortunately, this goal is very difficult to achieve, because the solutions to a formula $\phi$ cannot be randomly picked. Instead, $\phi$ must be repeatedly \textit{solved} to discover its solutions. (This is in contrast to design spaces consisting of parameter ranges, where it is possible to uniformly sample the space.) Furthermore, efficient solvers, such as SAT/SMT solvers based on DPLL search, cannot be viewed as uniformly sampling the solution space. They employ carefully researched heuristics [] for finding the \textit{next} solution quickly using information about solutions already found. This means the solver may compute a long sequence of similar solutions, before producing another interesting point in the design space.

???

%We illustrate our approach with a case study where DSE explores different data paths of an embedded software architecture and different hardware platforms. The optimization problem takes into account performance estimates of CPU and bus utilization derived from discrete event simulation. The well-known technique of \textit{Naive Bayesian Learning} is employed to estimate the key design choices. 

This paper is organized as follows: Section \ref{RelatedWork} outline the related work. Section \ref{CaseStudy} presents a case study and points out the degrees of freedom in the corresponding non-uniform design spaces. Section \ref{Encoding} describes the encoding of these design spaces in \FORMULA{}.

???

\section{Related Work} \label{RelatedWork}

\cite{Mariani2010,Ascia2007} and others -- uniform design spaces

\cite{Kakita2006} developed an algebraic approach for DSE
of dataflow systems. In this approach, each point in the de-
sign space is defined as a dataflow graph. Graph rewrite
rules are applied to an initial graph iteratively to generate a
set of alternative designs that preserve the scheduling con-
straints of the original design. The authors tackle the prob-
lem of the exponential growth in the design space by rep-
resenting regularity in structures with compact recurrence
relations. 


\cite{Salcic2007} Genetic

\section{Case Study} \label{CaseStudy}

Possible designs of a non-trivial embedded system form a non-uniform space. To demonstrate this, we will use a case study based on the Skinput project \cite{Harrison2010} that ``appropriates the human body as an input surface. Skinput resolves the location of finger taps on the arm and hand by analyzing mechanical vibrations that propagate through the body. This approach provides an always available, naturally portable, and on-body finger input system''.

\subsection{Basic Abstractions}

The high-level structure of Skinput is the following: An array of sensors collect vibration amplitudes from the skin and pass this data forward to be classified as a certain gesture. First, a number of features such as average, standard deviation, FFT and center of masses of power spectra, are computed for every sensor. Then, these features are processed by an \mbox{SVM-based} classifier that determines the type of the gesture being observed.

To model the design space of different implementations of Skinput, we used the following abstraction: We view software as manipulating \emph{values} as inputs and outputs (these model Skinput's features), where some values can be \emph{primary} meaning that they are not computed inside the system (this implicitly models sensors). The values that constitute the output to the user are marked as \emph{target}. 

Units of software are called \emph{programs}; they relate input values to output ones. Programs rely on particular \emph{capabilities} of hardware, such as availability of certain instructions.

\begin{exmp}[Average] Consider a program $Avg_{DIV}(\overrightarrow{x}, n)$ ($Avg$ stands for ``average'') that computes a value $\sum\limits_{i=0}^n x_i / n$ given two other values: vector $\overrightarrow{x}$ and its length $n$. Assume $Avg_{DIV}$ relies on a hardware implementation of devision; then it requires the following capabilities: $ADD$ and $JMP$ to compute a sum in a loop and $DIV$ to divide it by $n$. On the other hand, a program $Avg_{noDIV}$ that computes the same value but is designed for processors with no built-in division, would require capabilities needed to implement division using simpler instructions.
\end{exmp}

Hardware platform is modeled as a number of \emph{processors} communicating through \emph{media}. Every hardware element is characterized by its \emph{type}. Processor types specify capabilities the processors provide and medium types they can be connected on. In general, there can be many processors connected on the same medium.

Each point in the design space design includes 
\begin{itemize}
\item a hardware topology: processors connected by media,
\item a software configuration: programs that take values as inputs and send resulting values over to other programs,
\item a mapping that assigns programs to be executed on particular processors.
\end{itemize}
Obviously, this abstraction is not limited to our case study and can be used to model a wide range of embedded systems.

\subsection{Degrees of Freedom}

Let us examine the degrees of freedom present in the abstraction described above.

On the hardware level, there are two main degrees of freedom. On the one hand, points in the design space may have different topology of the hyper-graph formed by processors and media. For example, one can have a star-like topology or a ring-like one. On the other hand, each hardware element may have a type from a predefined set. Note that the topology restricts (or is restricted by) the element types as they may not allow to connect some processors on some media.

....

\section{Encoding Design Spaces in \FORMULA} \label{Encoding}

\newcommand{\DataSig}{\Sigma}
\newcommand{\FreeCons}{F}
\newcommand{\Consts}{C}
\newcommand{\Vars}{V} 

To formally specify design spaces we used the \FORMULA{} language \cite{??}. In \FORMULA{}, the user defines a signature $\DataSig$ that includes \emph{free constructors}, constants of basic types such as \texttt{Integer} or \texttt{String}, and variables. A design is then represented as a set of terms over $\DataSig$. 

For our case study, we defined a signature corresponding to the abstraction described in the previous section. For example, processors and their capabilities are captured by the following free constructors:

{\scriptsize\begin{verbatim}
  ProcessorType : (name : String).    
  Capability : (name : String).
  CapabilitySupported : (pt : ProcessorType, c : Capability).    
  ConnectionSupported : (pt : ProcessorType, mt : MediumType).
    
  MediumType : (name : String).

  Processor : (name : String, type : ProcessorType).
  Medium : (name : String, type : MediumType).    
  Connection : (processor : Processor, medium : Medium).
\end{verbatim}}

The following terms, as a part of a design representation, describe a simple processor type and two processors:    

{\scriptsize\begin{verbatim}
  CPU is ProcessorType("CPU"), // Bound variable
    CapabilitySupported(CPU, Capability("ADD")),
    CapabilitySupported(CPU, Capability("JMP")),
  Processor("cpu1", CPU),
  Processor("cpu2", CPU)
\end{verbatim}}

A \emph{legal} design must fulfill a number of constraints. For example, 
\emph{``processors must be compatible with the media they are connected to''} --- is a typical constraint.
In \FORMULA{}, constraints are expressed as a logic program that takes a set of terms as an input and evaluates to true iff the terms satisfy all the constraints. The following fragment of \FORMULA{} code shows how the constraint mentioned above can be encoded in a logic program:

{\scriptsize\begin{verbatim}
  unsupportedConnection(conn) :- 
    conn is Connection(Processor(_, ptype), Medium(_, mtype)), 
    fail ConnectionSupported(ptype, mtype).
  conforms :? fail unsupportedConnection(_).
\end{verbatim}}

In this example, a term with \texttt{unsupportedConnection} as a root constructor will be created for every connection between a processor and a medium of an unsupported type. The last line expresses the fact that in a legal design no such terms may appear. This is done by defining a special \emph{query} named \texttt{conforms}. A query roughly corresponds to a boolean variable computed by the logic program. The value of the \texttt{conforms} query is considered to be the result of the program written in \FORMULA{}. In our example \texttt{conforms} will be true iff no  \texttt{unsupportedConnection} terms are around.

Other constraints can be expressed in the same manner. To give some examples from software and mapping domains, consider the following constraints:
\begin{itemize}
  \item every target value that is not primary must be computed by some program;
  \item the capabilities required by a program must match the ones available on the processor it is mapped to.
\end{itemize}

For sampling, \FORMULA{} symbolically executes the logic program $P$ representing the constraints and converts it into an SMT-formula $F$, such that e
very satisfying assignment to variables in $F$ corresponds to a set of input terms that makes the \texttt{conforms} query in $P$ true. In order to obtain these assignments, a state-of-the-art SMT solver is applied to $F$.

\section{User-Defined Problem Descriptions}

As we mentioned before, the free constructors in $\DataSig$ describe the kinds of elements that constitute individual designs, and relations between them. The constraints restrict these relations according to what the constructors are intended to mean. These predefined ingredients are common for a wide range of systems as they just capture the overall structure of the system and do not restrict its functionality. 

To describe a particular design problem, such as the one for Skinput, one has to say what designs are \emph{relevant} for this problem. This is done by specifying ``building blocks'' such designs \emph{may} use: particular types of hardware, values and programs to process them. For example, all the user specifies about hardware may be the following (processor types must include with descriptions of their capabilities and supported media):
\begin{itemize}
  \item Processor types: MSP430, PIC32;
  \item Medium types: SPI, I$^2$C;
\end{itemize}
This specification allows all possible topologies connecting processors of types MSP430 and/or PIC32 by media of type SPI and/or I$^2$C in a legal way.

For the software, a set of values and programs manipulating these values must be defined, where every program declares the required capabilities. This may encode many ways of computing the same values. For example, suppose the only primary value is a vector $X$, one other value is the average $E[X]$, and the target value is variance $Var(X)$. In this situation, the user can specify two possible programs computing the target value: first one can directly compute variance as follows:
$$PVar_1(X) = \frac{\sum \left( \sum X_i \middle/ |X| - X_i \right)^2}{|X|},$$
whereas the second one can make use of a pre-computed average value and take it as an input:
$$PVar_2(X, E[X]) = \frac{\sum \left( E[X] - X_i \right)^2}{|X|}.$$
This specification allows two possible \emph{data paths} from $X$ to $Var(X)$: directly or through $E[X]$, and each legal design can contain one of them (our constraints prohibit choosing two paths in the same design). Note that the distinction between different implementations (e.g., requiring built-in division or not) can be applied here as well, producing more possible data paths.

The user provides the ``building blocks'' as a set of terms that is called a \emph{partial model}. Technically, this extends the set of predefined constraints: roughly speaking, it forces the designs to include the terms from the partial model. 

\section{title}

\subsection{Solving Design Spaces}
We now introduce some notation to discuss constraint generation and solving. 
\subsection{Data and Design Spaces}
The input to a logic program is a finite set of data. The shape of this data is characterized by an algebraic signature, which we call the \textit{data signature}.
\begin{defn}[Data Signature] The data signature $\Sigma$ is a structure:
\begin{equation}
\Sigma \DefinedToBe ( C, D, V ).
\end{equation}
\begin{enumerate}
\item $C$ is a (possibly infinite) set of nullary function symbols called constants.
\item $D$ is a finite set of non-nullary function symbols called data constructors.
\item $V$ is an infinite set of nullary function symbols called variables.
\end{enumerate}
The sets $C$, $V$, and $D$ are pairwise disjoint.
\end{defn}
Let $\sigma,\sigma_1,\ldots$ range over members of $C$, $x,y,y_1,\ldots$ range over members of $V$, and $f,g,g_1,\ldots$ range over members of $D$. A $\Sigma$-\textit{term} is a sequence of function applications (respecting arity) and $\terms{\Sigma}$ is the set of all such terms (or even $\tclear$ when context is clear). Terms without variables are called \textit{ground terms}. The \textit{Herbrand Interpretation} of $\Sigma$ assumes every term stands for itself and no other. This is the interpretation we use for data terms. 

\begin{exmp}[Directed Graphs] Consider the data signature:
\begin{displaymath}
\Sigma_G \DefinedToBe (v_0,v_1,v_2, v_3, e(,), V).
\end{displaymath}
where $C = \{v_0,v_1,v_2, v_3 \}$ is a finite set of vertex labels and $V$ is in arbitrary set of variables. A labeled directed graph $G$ over the vertices $C$ is a set of $\Sigma_G$-terms, such as the three-star below:
\begin{displaymath}
G_3 \DefinedToBe \{ e(v_0,v_1), e(v_0,v_2), e(v_0,v_3) \}.
\end{displaymath}
\end{exmp}
\noindent Terms can encode relations, like the edge relation above, but can also directly represent recursive structures.
\begin{exmp}[Binary Trees] This signature encodes unlabeled binary trees:
\begin{displaymath}
\Sigma_{BT} \DefinedToBe (nil, node(,), V)
\end{displaymath}
and this a small complete binary tree:
\begin{displaymath}
T \DefinedToBe \{ node(node(nil,nil),node(nil,nil)) \}.
\end{displaymath}
\end{exmp}

Let $\Pi$ be a logic program, $q$ be a query defined in $\Pi$, and $X$ be a finite set of ground terms. Then $q$ evaluates to true on the input $X$ if and only if there is a derivation of $q$ using only the rules of $\Pi$ and $X$; $eval(\Pi,X,q)$ denotes this evaluation. The input $X$ can be viewed as a database of facts that are used by $\Pi$ to justify $q$. The set of all such solutions to $q$ forms a design space:
\begin{equation}
\sols{\Pi,q} \DefinedToBe \{ X \subseteq \tclear \ | \ eval(\Pi,X,q) \}.
\end{equation}   
Each point in the space is finite set of data carrying detailed information about an architecture. 

\subsection{Symbolic Execution}
One approach for finding solutions to the design space is by \textit{symbolic execution} of the logic program []. In this case, $\Pi$ is evaluated over an input set of non-ground terms $X$, such as:
\begin{equation}
X \DefinedToBe \{ e(x,y), e(y,z), e(z,x) \}.
\label{ex:3cycle}
\end{equation}
During symbolic execution, a rule leading to a derivation of $q$ may encounter data terms containing variables. Whenever this occurs a constraint on the input variables is computed, which describes the values that can make the rule applicable. If symbolic execution terminates, then the result is a simpler existentially quantified formula $\psi$. For example,
\begin{displaymath}
\Pi \DefinedToBe \{ \ loop(a) \ :\!- \ e(a,a). \  \ hasLoop \ :? \ loop(a). \ \}
\end{displaymath}
Symbolic execution of $\Pi$ on $X$ for the $hasLoop$ query produces the formula:
\begin{displaymath}
\psi \DefinedToBe \exists x,y,z \ (x = y) \vee (y = z) \vee (x = z).
\end{displaymath}
We write $\seval{\Pi}{X}{q}$ the formula $\psi$ produced by symbolic execution.

A solution to $\psi$ is a function $\nu$ from variables to ground terms, such that $\psi[x_i/\nu(x_i)]$ is true. The simplified form of $\psi$ allows it to be solved by state-of-the-art theorem provers, such as the satisfiability modulo theories (SMT) solver Z3[]. Importantly, the solutions to $\psi$ induce members of $\sols{\Pi,q}$, i.e. $X[x_i/\nu(x_i)] \in \sols{\Pi,q}$. Due to this correspondence, we write $\sols{\psi} \subseteq \sols{\Pi,q}$.
For example, one solution to $\seval{\Pi}{X}{hasLoop}$ is:
\begin{displaymath}
\nu(x) = v_0, \ \nu(y) = v_1, \ \nu(z) = v_0.
\end{displaymath}
This induces a member of the design space:
\begin{displaymath}
\nu(X) = \{ e(v_0,v_1), \ e(v_1,v_0), \ e(v_0,v_0) \}.
\end{displaymath}
For the remainder of this paper, we assume constraints a generated by symbolic execution.

\section{Random Sampling By Equivalence Classes}
Ideally, an exploration algorithm should enumerate the points of a design space randomly with a uniform distribution; this (probabilistically) guarantees that a diverse range of architectures are observed during an arbitrary run of the algorithm. Unfortunately, this goal is very difficult to achieve, because the solutions to a formula $\psi$ cannot be randomly picked. Instead, $\psi$ must be repeatedly \textit{solved} to discover its solutions. (This is in contrast to design spaces consisting of parameter ranges, where it is possible to uniformly sample the space.) Furthermore, efficient solvers, such as SAT/SMT solvers based on DPLL search, cannot be viewed as uniformly sampling the solution space. They employ carefully researched heuristics [] for finding the \textit{next} solution quickly using information about solutions already found. This means the solver may compute a long sequence of similar solutions, before producing another interesting point in the design space.

This problem can be addressed by defining equivalence classes $E = \{[Y_1],\ldots,[Y_n]\}$ on an over-approximation $\mathbb{X} \supseteq \sols{\Pi,q}$ of the design space. Solutions in the same equivalence class are, by definition, uninteresting. Assuming equivalence classes can be randomly sampled and enforced as additional constraints to the solver, then the design space can be randomly sampled. In particular, if $[Y]$ is an equivalence class, then let $\theta([Y])$ be a constraint such that $\sols{\psi \wedge \theta([Y])} \subseteq [Y]$. The general sketch of the sampling algorithm is:
\begin{algorithm}
\caption{Naive sampling by equivalence classes}
\label{alg:naive}
\begin{algorithmic}[1]
\Procedure{NaiveExplore}{$\psi, E$}\Comment For finite $E$.
\While{$E \neq \emptyset$}
\State $[Y] \gets C\!hoose(E)$
\State $E \gets E - [Y]$
\If{$I\!sSat(\psi \wedge \theta([Y]))$}
\State $Report(Solve(\psi \wedge \theta([Y])))$
\EndIf
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

Unfortunately, the naive algorithm has a major drawback: There may be many equivalence classes containing no solutions, i.e. $\sols{\psi \wedge \theta([Y])} = \emptyset$. In this case, the algorithm requires many iterations before reporting a solution. The number of iterations $n$ required to obtain at least one solution with probability $p$ follows the hypergeometric distribution:
\begin{equation}
n \approx \frac{ln(1-p)}{ln(1-r)}
\end{equation}
where $r$ is the ratio of equivalence classes with solutions to the total number of equivalence classes. Suppose $k$ solutions are distributed across $e^k$ equivalence classes, then the expected time to the first solution is approximately $O(e^k)$. The algorithms we present correct the naive sampling algorithm to achieve better run-time performance, while sacrificing some of the uniformity. Next, we describe a useful category of equivalence classes.

\subsection{Equivalence by Isomorphism}
We investigate the sampling problem when equivalence classes are defined by isomorphisms between sets of terms. Such isomorphisms generalize graph isomorphisms, and so they require the solver to return a sequence of structurally non-isomorphic points in the design space. These particular equivalence classes are useful for enumerating design spaces, because they return globally distinct solutions without additional domain-specific definitions of equivalence.  

\begin{defn}[Homomorphisms] Let $X$ and $Y$ be finite sets of $\Sigma$-terms. A \textit{homomorphism} from $X$ to $Y$ is a function $\varphi$ from terms to terms satisfying:
\begin{enumerate}
\item $\varphi(\sigma) = \sigma$.
\item $\varphi(f(t_1,\ldots,t_n)) = f(\varphi(t_1),\ldots,\varphi(t_n))$.
\item $\varphi(X) = Y$.
\end{enumerate}
Let $\Hom{X}{Y}$ denote the set of all homomorphisms from $X$ to $Y$. If $\Hom{X}{Y} \neq \emptyset$, then $Y$ is a homomorphic image of $X$. Let $\HImg{X}$ denote the set of all homomorphic images of $X$.
\end{defn}

\begin{defn}[Isomorphisms] $X$ and $Y$ are isomorphic if $\Hom{X}{Y} \neq \emptyset$ and $\Hom{Y}{X} \neq \emptyset$. We write $X \iso Y$ to indicate that $X$ and $Y$ are isomorphic.
\end{defn}

\begin{defn}[Equivalence By Isomorphism] Let $\mathbb{X}$ be a (possibly infinite) set of finite sets of  $\Sigma$-terms. Then $E_{\iso}(\mathbb{X})$ is a set of equivalence classes over $\mathbb{X}$. The members of each class is given by:
\begin{equation}
[X] \DefinedToBe \{ Y \ | \ X \iso Y \}.
\end{equation} 
\end{defn}

\begin{lem} $NaiveExplore(\seval{\Pi}{X}{q},E_{\iso}(\HImg{X}))$ uniformly samples the design space generated by $\seval{\Pi}{X}{q}$.
\end{lem}
\begin{proof}
First, by construction $\sols{\psi} \subseteq \HImg{X}$. Second, $E_{\iso}$ contains a finite number of equivalence classes, which is bounded by the number of partitions over $var(X)$. Third, for every equivalence class $[Y]$ there is a formula $\theta([Y])$ such that $\sols{\theta([Y])} = [Y]$.
\end{proof}

\begin{exmp}Consider $X = \{ e(x,y), e(y,z), e(z,x) \}$ and $Y = \{ e(x,y), e(y,z) \}$. Then $Y \in \HImg{X}$ and 
\begin{equation}
\theta([Y]) = \begin{array}{l}
 (x = y \wedge x \neq z \wedge y \neq z) \ \vee \\  
				      (x = z \wedge x \neq y \wedge y \neq z) \ \vee \\
				      (y = z \wedge x \neq y \wedge x \neq z).
\end{array}				      
\end{equation}
\end{exmp}

\section{}

Algorithm \ref{alg:naive} samples the space uniformly (without replacement) and obviously terminates. Unfortunately, there may be many equivalence classes that do not contain a model, i.e. $sols(\psi \wedge \theta([X])) = \emptyset$. In this case, the algorithm may run for many iterations before a solution is reported. The number $n$. of iterations required to obtain at least one solutions with probability $p$ follows the hypergeometric distribution:
\begin{equation}
n \approx \frac{ln(1-p)}{ln(1-r)}
\end{equation}
where $r$ is the ratio of equivalence classes with solutions to the total number of equivalence classes.

\section{Op}
Applying the sampling algorithm to equivalence classes based on term isomorphisms is problematic for three reasons: 



\section{Learning and Refinement}

\section{Results}

\section{Discussion and Conclusion}


\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,DAC2011}
\end{document}


