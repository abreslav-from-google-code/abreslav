grammar Pascal;
options {
  output=AST;
  ASTLabelType=CommonTree;
}
@header {
  package pascal.parser;
}
@lexer::header {
  package pascal.parser;
}

program	:	head? subroutines var? block '.'!;
head	:	'program'^ Id ';'!;
var	:	'var'^ varDecl+;
varDecl	:	idList ':'! type^ ';'!;
idList	:	Id (','! Id)*;
type	:	Id;
block	:	'begin'^ statements 'end'!;
statement
	:	
	| nonEmptyStatement
	| '|'^ statement '!'? JavaStr
	| Num ':'^ statement;
nonEmptyStatement
	:	assign | ifThenElse | whileDo | block;
statements
	:	statement (';'! statement)*;
assign	:	Id ':='^ expression;
expression
	:	sum (compareOp^ sum)*;
sum	:	mul (plusOp^ mul)*;
mul	:	factor (mulOp^ factor)*;
factor	
	: '('! expression ')'! 
	| '+'! factor 
	| '-' factor -> ^('-' '-' factor) 
	| 'not'^ factor 
	| 'true'
	| 'false'
	| Id 
	| Num;
compareOp
	:	'<' | '>' | '<=' | '>=' | '=' | '<>';
plusOp	:	'+' | '-' | 'or' | 'xor';
mulOp	:	'*' | 'div' | 'mod' | 'and';
ifThenElse	:	'if'^ expression 'then'! statement (options {k=0;}:'else'^ statement)?;
whileDo 	:	'while'^ expression 'do'! statement;

subroutines
	: (procedure | function) *;
procedure
	: 'procedure'^ signature ';'! sbrBody;
function
	: 'function'^ signature ':'! type ';'! sbrBody;
signature
	: Id ('('! varDecl+ ')'!)?;
sbrBody
	:  var? block ';';

Id	:	('a'..'z' | 'A'..'Z')+; 
Num	:	('0'..'9')+;
String : '\"' (options{greedy=false;}:.)* '\"';

WS : (
	(' ' | '\t' | '\n' | '\r')+ 
	| '(*' (options{greedy=false;}:.)* '*)'
	| '//' (options{greedy=false;}:.)* '\n'
	)  
	{skip();} ;
	
JavaStr : '{{' (options{greedy=false;}:.)* '}}';