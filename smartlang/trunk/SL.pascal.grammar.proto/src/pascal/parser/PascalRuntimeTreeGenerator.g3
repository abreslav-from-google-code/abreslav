tree grammar PascalRuntimeTreeGenerator;

options {
  output=template;
  tokenVocab=Pascal;
  ASTLabelType=CommonTree;
}

@header {
  package pascal.parser;
}

program 
	: head? var? block
	-> program(head={$head.st}, var={$var.st}, block={$block.st});
head : ^('program' Id);
var : ^('var' variables+);
variables : ^(Id (Id)*);
block 
	: ^('begin' (st+=statement)*)
	-> block(statements={$st});
statement 
	: assign -> {$assign.st}
	| ifThenElse -> {$ifThenElse.st} 
	| whileDo -> {$whileDo.st}
	| block -> {$block.st}
	| ^('|' st=statement assertExpr)
	-> assertedStatement(stmt={$st.st}, asrt={$assertExpr.st})
	| ^(':' assertExpr st=statement)
	-> assertedStatement(stmt={$st.st}, asrt={$assertExpr.st})
	;
assign
	: ^(':=' Id expression)
	-> assign(id={$Id}, exp={$expression.st});
ifThenElse 
	: ^('if' expression th=statement)
	-> ifThenElse(cond={$expression.st}, then={$th.st})
	| ^('else' ^('if' expression th=statement) el=statement)
	-> ifThenElse(cond={$expression.st}, then={$th.st}, els={$el.st}) 
	;
whileDo 
	: ^('while' expression statement)
	-> while(cond={$expression.st}, body={$statement.st})
	;
expression
    : ^(op='+' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st})
    | ^(op='-' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st})  
    | ^(op='*' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st})  
    | ^(op='div' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st})  
    | ^(op='mod' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st})  
    | ^(op='<' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st})
    | ^(op='>' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st}) 
    | ^(op='>=' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st}) 
    | ^(op='<=' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st}) 
    | ^(op='=' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st}) 
    | ^(op='<>' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st}) 
    | ^(op='and' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st}) 
    | ^(op='or' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st}) 
    | ^(op='xor' a=expression b=expression)
    -> binaryOp(l={$a.st}, op={$op.text}, r={$b.st}) 
    | ^(op='-' '-' r=expression)
    -> unaryOp(r={$r.st}, op={$op.text})  
    | ^(op='not' r=expression)
    -> unaryOp(r={$r.st}, op={$op.text})  
	| Id
	-> id(name={$Id.text})
	| 'true'
	-> const(value={"true"})
	| 'false'
	-> const(value={"false"})
	| Num
	-> const(value={$Num.text})
	;
	
assertExpr
	: JavaStr 
	-> assertJavaBlock(java={$JavaStr.text.substring(2, $JavaStr.text.length() - 2).replaceAll("\\$([a-zA-z0-9_]*)", "unit.get_$1()")})
	| '!' JavaStr
	-> assertJavaExpression(
		expr={$JavaStr.text.substring(2, $JavaStr.text.length() - 2).replaceAll("\\$([a-zA-z0-9_]*)", "unit.get_$1()")},
		comment={"line " + $JavaStr.line + ": " +$JavaStr.text.substring(2, $JavaStr.text.length() - 2)}
	) 
	| Num
	-> assertNumberOfVisits(count={$Num.text}, msg={"line " + $Num.line})
	;
	
/*
	| ^('!' JavaStr) 

*/