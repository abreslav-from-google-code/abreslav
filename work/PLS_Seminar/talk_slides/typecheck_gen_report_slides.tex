\documentclass[screen]{beamer}
\usepackage{listings}
\usepackage{color}
\usepackage{bold-extra}
\usepackage{wasysym}
\usepackage{beamerthemesplit}
\usepackage{graphicx}
\usepackage{tikz}
\usetheme{default}

\usepackage{underscore}
\usepackage{ifthen}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{url}

\newcommand{\Tcg}{\textsc{Tcg}}
\newcommand{\code}[1]{\texttt{#1}}
\newcounter{premise}
\newcommand{\premise}[2]{
\ifthenelse{\equal{\arabic{premise}}{1}}{\\}{}%
    \setcounter{premise}{1}%
    #1\vdash#2%
}
\newcommand{\ifnotempty}[2]{\ifthenelse{\equal{#1}{}}{}{#2}}
\newcommand{\tcgrule}[5]{%
	\setcounter{premise}{0}%
$$%
    \ifnotempty{#1}{%
        \forall \left(#1\right)\;%
    }%
    \dfrac{%
	    \begin{array}[b]{l}%
	    #2%
            \end{array}%
    }{%
            #3%
    }%
    \;\ifnotempty{#4}{(\mathtt{#4}\ifnotempty{#5}{[\mathbf{#5}]})}%
$$%
}

\title{A Generator for Type Checkers}
\subtitle{A report on the PhD thesis by H. Gast (2004)}
\author{Andrey Breslav}
\institute{ITMO University, St. Petersburg / University of Tartu}


\begin{document}

\frame{\titlepage}

\begin{frame}[t,fragile]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{A workflow of a compiler}%
program -> lexer -> parser -> AST -> type checker -> YES | NO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{frame}

\frame{
	\frametitle{Problem statement}

	Describe type checkers with a declarative language.\\
	Some features to support:
	\begin{itemize}
		\item Simply-typed $\lambda$-calculus
		\item Polymorphic \textbf{let}
		\item Mutually recursive functions
		\item Inheritance of classes in OOP
		\item Generic programming
		\item \ldots
	\end{itemize}
}

\begin{frame}[t,fragile]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Workflow of \Tcg{}}%

\begin{figure}[htp]
\centering
\includegraphics[width=.7\textwidth]{../generator}
\caption{The \Tcg{} Generator}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{frame}

\frame{
	\frametitle{Runtime behaviour}

\begin{figure}[htp]
\centering
\includegraphics[width=.7\textwidth]{../runtime}
\caption{The \Tcg{} Type Checker at Run Time}
\end{figure}
}

\frame{
	\frametitle{What the interpreter does?}

	$\lambda f : \tau \rightarrow \sigma . \lambda x : \tau . f\,x$

	\begin{tikzpicture}[
		level 1/.style={sibling distance=3cm},
		level 2/.style={sibling distance=1cm}		
		] 
		\node {$\lambda$}
		    child {node {$f$}}
		    child {node {$\rightarrow$}
		    	child {node {$\tau$}}
			child {node {$\sigma$}}
		    }
		    child {node {$\lambda$}
		    	child {node {$x$}}
			child {node {$\tau$}}
			child {node {\texttt{app}}
				child {node {$f$}}
				child {node {$x$}}
			}
		    }
		    ;
                \end{tikzpicture}

}

\frame{
	\frametitle{Components of a \Tcg{} specification}
	A specification in \Tcg{} describes
	\begin{itemize}
		\item Lexicon
		\item Context-Free Syntax
		\item Abstract Syntax
		\item Typing Rules
		\item Pretty-Printing Rules
	\end{itemize}
}

\begin{frame}[fragile]
	\frametitle{Syntax of Simply-Typed $\lambda$-Calculus}
\begin{verbatim}
file: top_wrap EOF {! run ~save: 
                     [ (input.base^".rls",
                       [ ("define", "save_defined") ]) ] 
                     $1 
                   !}
top_wrap: tops        --> tops($1)

tops: top             --> $1 :: []
    | top ";;" tops   --> $1 :: $3

top: exp              --> $1

exp: ID               --> id[$1]
   | exp exp          --> apply($1,$2)
   | "\\" ID "." exp  --> lambda(id[$2],$4)
   | "(" exp ")"      --> $2
\end{verbatim}

\end{frame}

\frame{
	\frametitle{AST production language}
The AST productions are specified after \texttt{'-->'}, the language uses
\begin{itemize}
 \item \code{\$<number>} --- reference items on the left-hand side;
 \item \code{<node_type>(<children>)} --- node constructors;
 \item \code{head::tail} --- lists, \code{[]} is empty list;
 \item \code{<class>[<value>]} --- opaque terms.
\end{itemize}
}

\begin{frame}[fragile]
	\frametitle{Example $\lambda$ expression}
\begin{tabular}{ll}
Mathematical notation: & $(\lambda f.\lambda x. f\; x)\; g\; y$\\
Textual notation: & \code{(\textbackslash f.\textbackslash x.f x) g x}\\
Abstract Syntax Tree:&
\end{tabular}
\begin{center}
	\begin{tikzpicture}[
		level distance=.75cm,
		sibling distance=3cm,
%		level 1/.style={sibling distance=3cm},
%		level 2/.style={sibling distance=1cm}		
		] 
		\node {tops}
		child {node {::}
		    child {node {apply}
		    	child {node {apply}
				child {node {lambda}
					child {node {id[f]}}
					child {node {lambda}
						child {node {id[x]}}
						child {node {apply}
							child {node {id[f]}}
							child {node {id[x]}}
						}
					}
				}
				child {node {id[g]}}
		    	}
			child {node {id[y]}}
		    }
		    child {node {[]}}
		}
		;
                \end{tikzpicture}
\end{center}
%\begin{verbatim}
%tops(
%    apply(
%        apply(
%            lambda(id[f], 
%                lambda(id[x], 
%                    apply(id[f], id[x]))),
%            g),
%        x)
%    ::[]
%)
%\end{verbatim}	
\end{frame}

\begin{frame}[fragile]
	\frametitle{Typing rules}

A conventional typing rule:
\tcgrule{f, e, s, t}{
    \Gamma \vdash f : s \rightarrow t
    \hspace{20pt}
    \Gamma \vdash e : s
}{\Gamma \vdash f\; e : t}{apply}{}

\Tcg{} version:
\begin{columns}
	\column{.5\textwidth}
\begin{verbatim}
rule apply
  forall(f,e,s,t)
    apply(f,e) : t
  if f : fun(s,t)
  and e : s
\end{verbatim}
	\column{.5\textwidth}
\tcgrule{f, e, s, t}{
    \premise{}{f : s \rightarrow t}
    \premise{}{e : s}
}{f\,e : t}{apply}{}
\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Context modifiers}
The typing rule in \Tcg{}:
\tcgrule{x, e, s, t}{
    \premise{-( :_1 = x), +[ x : s ]}{e : t}
}{\lambda x. e : fun(s,t)}{lambda}{}
\begin{columns}
	\column{.6\textwidth}
\Tcg{} code:
\begin{verbatim}
rule lambda
  forall(x,e,s,t)
    lambda(x,e) : fun(s,t)
  if e : t
    under -( :.1.= x) + [ x : s ]
\end{verbatim}
	\column{.4\textwidth}
Context modifiers:
\begin{itemize}
	\item \code{-(:.1. = x)} 
	\item \code{+[ x : s ]}
\end{itemize}	
\end{columns}
\end{frame}

\begin{frame}[fragile]
	\frametitle{The search procedure}
A rule for the root of the tree:
\tcgrule{es, ts}{
\premise{}{\mathtt{[branch]}\; es : ts \; \mathbf{export} * \ldots}
}{tops(es)}{tops}{}
Initial context:
\begin{verbatim}
environment apply,lambda,tops
\end{verbatim}
\vspace{-1.75cm}
\begin{center}
	\begin{tikzpicture}[
		level distance=.75cm,
		sibling distance=3cm,
%		level 1/.style={sibling distance=3cm},
%		level 2/.style={sibling distance=1cm}		
		] 
		\node {tops}
		child {node {::}
		    child {node {apply}
		    	child {node {apply}
				child {node {lambda}
					child {node {id[f]}}
					child {node {lambda}
						child {node {id[x]}}
						child {node {apply}
							child {node {id[f]}}
							child {node {id[x]}}
						}
					}
				}
				child {node {id[g]}}
		    	}
			child {node {id[y]}}
		    }
		    child {node {[]}}
		}
		;
                \end{tikzpicture}
\end{center}

\end{frame}

\frame{
	More proof demonstration
}

\begin{frame}[fragile]
	\frametitle{A simple extension: Constants}
	Syntax:
\begin{verbatim}
    INT     --> int[$1]
  | "false" --> bool["false"]
  | "true"  --> bool["true"]
\end{verbatim}
Typing rules:
\tcgrule{i}{}{\mathtt{int[}i\mathtt{]}:\mathtt{int}}{int\_const}{}
\tcgrule{i}{}{\mathtt{bool[}i\mathtt{]}:\mathtt{bool}}{bool\_const}{}
\end{frame}

\begin{frame}[fragile]
	\frametitle{Built-in constructs}
Built-in function:
	\tcgrule{}{}{add : int \rightarrow int \rightarrow int}{add\_function}{}
Conditional operator:
\tcgrule{e_1,e_2,e_3,t}{
\premise{}{e_1 : bool}
\premise{}{e_2 : t}
\premise{}{e_3 : t}
}{\mathbf{if}\; e_1\; \mathbf{then}\; e_2\; \mathbf{else}\; e_3\; \mathbf{endif} : t}{if\_expr}{}
\end{frame}

\frame{
	\frametitle{Monomorphic \textbf{let}}

	Notation:
		\begin{center}\code{let x = e in e'}\end{center}
	Meaning:
		\begin{center}$(\lambda x.e')\,e$\end{center}
	Typing rule:
\tcgrule{x,e,e',s,t}{
\premise{}{e' : s}
\premise{-(:_1 = x), +[x : s]}{e : t}
}{\mathbf{let}\;x = e'\;\mathbf{in}\;e : t}{mono\_let}{}	
}

\frame{
	\frametitle{Rule extraction}
	

}

\frame{
	\frametitle{Forward application}
	
$$
\left.\begin{array}{r}
	\tcgrule{}{\ldots}{e' : s}{}{}\\
	+\hspace{14pt}\\
	\tcgrule{e,t}{e : t}{x : t}{}{}
\end{array}
\right\}
\Rightarrow 
\begin{array}{l}
	\tcgrule{}{\ldots}{x : t}{}{}
\end{array}
$$
}

\frame{
	\frametitle{Notation for forward application}
$$rule\_expression(rule\_expressions)$$
where each rule expression may be 
\begin{itemize}
	\item an inline rule (e.g., $x : s$), 
	\item a reference (e.g., $\mathtt{let\_binding}[x]$), 
	\item a rule extracted from the subproof of the premise number $i$ (e.g., $\langle 1 \rangle$, the premise must stay to the left of the current premise),
	\item the \textbf{environment} which refers to all the rules present in the context.
\end{itemize}
}

\frame{
	\frametitle{Reformulation of monomorphic \textbf{let}}
	
\tcgrule{x,e,e',s,t}{
    \premise{}{e' : s}
    \premise{-(:_1 = x), +[\mathtt{let\_binding}[x]](\langle 1 \rangle)}{e : t}
}{\mathbf{let}\;x = e'\;\mathbf{in}\;e : t}{let'}{}

Auxiliary rule:
\tcgrule{e,t}{\premise{}{e : t}}{\mathbf{y} : t}{let\_binding}{y}

}

\frame{
	\frametitle{Polymorphic \textbf{let} and recursion}

\tcgrule{x,e,e',s,t}{
    \premise{}{e' : s}
    \premise{-(:_1 = x), +[\mathtt{let\_binding}[x]](\langle 1 : [\forall] \rangle)}{e : t}
}{\mathbf{let}\;x = e'\;\mathbf{in}\;e : t}{let\_p}{}
\uncover<2>{
Recursion:
\tcgrule{x,e,e',s,t}{
    \premise{+[x : s]}{e' : s}
    \premise{-(:_1 = x), +[\mathtt{let\_binding}[x]](\langle 1 : [\forall] \rangle)}{e : t}
}{\mathbf{let}\;x = e'\;\mathbf{in}\;e : t}{let\_r}{}
}
}

\begin{frame}[fragile]
	\frametitle{Parallel bindings}
	Syntax:
\begin{verbatim}
exp: "let" bind_group "in" exp    --> let($2,$4)

bind_group: bind                  --> $1 :: []
          | bind "and" bind_group --> $1 :: $3

bind: ID "=" exp                  --> bind(id[$1],$3)
\end{verbatim}

Typing:
\tcgrule{}{
    \premise{}{typings\; of\; bindings}
    \premise{+[\mathtt{let\_binding}[x]](\langle bindings : [\forall] \rangle)}{e : t}
}{\mathbf{let}\;bindings\;\mathbf{in}\;e : t}{}{}

\end{frame}

\frame{
	\frametitle{Processing lists}
Does not work:
\tcgrule{}{
    \premise{}{typings\; of\; bindings}
    \premise{+[\mathtt{let\_binding}[x]](\langle bindings : [\forall] \rangle)}{e : t}
}{\mathbf{let}\;bindings\;\mathbf{in}\;e : t}{}{}

Recursive implementation:
$$\begin{array}{cc}
\tcgrule{}{
    {\vdash head}
    \hspace{15pt}
    {\vdash \mathtt{bind\_group}(tail)}
}{\mathtt{bind\_group}(head\;\mbox{\tt ::}\;tail)}{}{}
&
\tcgrule{}{}{\mathtt{bind\_group}(\mbox{\tt []})}{}{}
\end{array}$$
Use for parallel bindings:
\tcgrule{bs,e,t}{
\premise{}{\mathtt{bind\_group}(bs)}
    \premise{+[???](\langle ??? : [\forall] \rangle)}{e : t}
}{\mathbf{let}\;bs\;\mathbf{in}\;e : t}{}{}
}

\frame{
	\frametitle{The original work}

	Holger Gast, \emph{The Generator for Type Checkers}, University~of~T\"ubingen, 2004

	\footnotesize\url{http://www-pu.informatik.uni-tuebingen.de/users/gast/tcg.html}
}

\end{document}
