
A languages specification in \Tcg{} covers 
 # context-free syntax;
 # abstract syntax tree (AST) construction;
 # typing rules;
 # proof search instructions;
 # pretty-printing rules.

Context-free syntax is described by YACC-style productions \cite{YACC}, each grammar must have a start symbol called \code{file}. Productions may be annotated with AST building instructions (after \code{-->} sign) or a block of code to be executed after the production has been matched (in \code{\{!} \ldots \code{!\}} brackets). The \code{file} symbol is responsible for running type analysis, which is usually done by invoking \code{run} command:

\begin{code}
	file: top_wrap EOF {! run ~save: [ (input.base^".rls",
	                               [ ("define", "save_defined") ]) ] $1 !}
\end{code}

The arguments passed to the \code{run} function deal with saving results and are irrelevant for our discussion.

Following the logic of Chapter 4 of the original work, we will illustrate the main \Tcg{}'s features by examples starting from simply-typed $\lambda$-calculus. Its syntax is described by the following rules (we omit lexical definitions and documenting annotations):

\begin{code}
top_wrap: tops        --> tops($1)
tops: top             --> $1 :: []
    | top ";;" tops   --> $1 :: $3
top: exp              --> $1

exp: ID               --> id[$1]
   | exp exp          --> apply($1,$2)
   | "\\" ID "." exp  --> lambda(id[$2],$4)
   | "(" exp ")"      --> $2
\end{code}

The first three rules describe a sentence as a list of expressions (\code{exp}) separated by double-semicolons (\code{";;"}). The last rule describes a $\lambda$-expression in a usual way: as a variable, application, abstraction or bracketed expression. As mentioned before, instructions after \code{-->} symbols serve for AST-construction; there are several types of such instructions:
 * item references of the form \code{\$<number>} -- reference items on the left-hand side;
 * node constructors of the form \code{<node_type>(<children>)};
 * list constructors of the form \code{head::tail}, where \code{[]} denotes the empty list;
 * opaque term constructors of the form \code{<class>[<value>]} -- these will be explained later.

For example, here is a textual representation of the expression
$$(\lambda f.\lambda x. f x) g y$$
will be\\
\code{(\f.\x.f x) g x}\\
and an AST constructed from it is
\begin{code}
tops(
    apply(
        apply(
            lambda(id[f], 
                lambda(id[x], 
                    apply(id[f], id[x]))),
            g),
        x)
    ::[]
)
\end{code}

A \emph{typing judgement} in \Tcg{} is a pair 
$$term : type$$
where $term$ is a AST subtree and $type$ is term which structure is defined by typing rules. The typing rules are used by \Tcg{} to construct proofs of typing judgements, which are basically trees where the proven judgement is a root and all the edges are \emph{properly} labeled with rules (what ``properly'' means will be explained later). 

A generic typing rule consists of a set of universally quantified \emph{variables}, a list of \emph{premises}, a \emph{conclusion} and a list of \emph{parameters}. In \Tcg{} concrete syntax it is written like this:
\begin{code}
rule apply
  forall(f,e,s,t)
    apply(f,e) : t
  if f : fun(s,t)
  and e : s
\end{code}

In this example, \code{f}, \code{e}, \code{s} and \code{t} are the quantified variables, \code{apply(f,e)} is the conclusion, \code{f : fun(s, t)} and \code{e : s} are the premises. In more familiar logical notation it can be written like this:
\tcgrule{f, e, s, t}{
    \premise{\Gamma |- f : s \rightarrow t}
    \premise{\Gamma |- e : s}
}{\Gamma |- f e : t}{apply}{}

So this rule expresses the typing for application. To construct a proof for a judgement $f e : t$ we have to build a tree, where this judgement will be the root node and its children will be obtained by \emph{application} of this rule. So the root node will have two children having the forms of the premises, where $f$, $e$ and $t$ are already known (they appear in the initial judgement) and $s$ must be inferred. Each node in the tree is marked with the rule applied at this node, in our case the root node will be marked with \code{apply} rule. To complete the proof we must construct subtrees proving the children, so that leaves of the tree will be marked with application of rules which have no premises. This example provides a rough intuition about proof structure, we will improve it further (for formal definitions see Chapter 2 of the original thesis).

We have written $\Gamma$ in the example above to provide the most familiar notation, but in \Tcg{} the context is ``global'' for the rule application and is being modified each time a rule is applied (the modified version is relevant to the subtree of the vertex marked with the applied rule). This is motivated by the backward style of reasoning adopted by \Tcg{}: when we apply a rule, we create new vertices in the proof tree and change our knowledge about currently available typing information. These changes are expressed by \emph{context modifiers} which are written in the premises instead of context variables like $\Gamma$. For example, here is the rule for $\lambda$-abstraction:
\begin{code}
rule lambda
forall(x,e,s,t)
lambda(x,e) : fun(s,t)
if e : t
under -( :.1.= x) + [ x : s ]
\end{code}
Here is the tree-like form of this rule:
\tcgrule{x, e, s, t}{
    \premise{-( :_1 = x), +[ x : s ] |- f : s \rightarrow t}
    \premise{ |- e : s}
}{f e : t}{apply}{}
The context modifiers here are \code{-( :.1.= x)} and \code{+[ x : s ]}.

The context modifiers are applied to the context available a the root of the subtree, so the are relative to the context of the conclusion, that is why we do not write anything denoting context under the like.

The rule \code{apply} mentioned above has no context modifiers, thus in tree-like form it is written as follows:
\tcgrule{f, e, s, t}{
    \premise{ |- f : s \rightarrow t}
    \premise{ |- e : s}
}{f e : t}{apply}{}


rule tops
forall(es,ts)
tops(es)
if [branch] es : ts export* ...

environment apply,lambda,tops

----
Polymprphic let:

  rule let_poly
  forall(x,e,e’,s,t)
    let(x,e,e’) : t
  if e : s
  and e’ : t
  under -(:.1.= x) +let_binding[x](<1: [quantify]>)
