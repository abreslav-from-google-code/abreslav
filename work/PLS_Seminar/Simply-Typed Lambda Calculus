
A languages specification in \Tcg{} covers 
 # context-free syntax;
 # abstract syntax tree (AST) construction;
 # typing rules;
 # proof search instructions;
 # pretty-printing rules.

Context-free syntax is described by YACC-style productions \cite{YACC}, each grammar must have a start symbol called \code{file}. Productions may be annotated with AST building instructions (after \code{-->} sign) or a block of code to be executed after the production has been matched (in \code{\{!} \ldots \code{!\}} brackets). The \code{file} symbol is responsible for running type analysis, which is usually done by invoking \code{run} command:

\begin{code}
	file: top_wrap EOF {! run ~save: [ (input.base^".rls",
	                               [ ("define", "save_defined") ]) ] $1 !}
\end{code}

The arguments passed to the \code{run} function deal with saving results and are irrelevant for our discussion.

Following the logic of Chapter 4 of the original work, we will illustrate the main \Tcg{}'s features by examples starting from simply-typed $\lambda$-calculus. Its syntax is described by the following rules (we omit lexical definitions and documenting annotations):

\begin{code}
top_wrap: tops        --> tops($1)
tops: top             --> $1 :: []
    | top ";;" tops   --> $1 :: $3
top: exp              --> $1

exp: ID               --> id[$1]
   | exp exp          --> apply($1,$2)
   | "\\" ID "." exp  --> lambda(id[$2],$4)
   | "(" exp ")"      --> $2
\end{code}

The first three rules describe a sentence as a list of expressions (\code{exp}) separated by double-semicolons (\code{";;"}). The last rule describes a $\lambda$-expression in a usual way: as a variable, application, abstraction or bracketed expression. As mentioned before, instructions after \code{-->} symbols serve for AST-construction; there are several types of such instructions:
 * item references of the form \code{\$<number>} -- reference items on the left-hand side;
 * node constructors of the form \code{<node_type>(<children>)};
 * list constructors of the form \code{head::tail}, where \code{[]} denotes the empty list;
 * opaque term constructors of the form \code{<class>[<value>]} -- these will be explained later.

For example, here is a textual representation of the expression
$$(\lambda f.\lambda x. f x) g y$$
will be\\
\code{(\f.\x.f x) g x}\\
and an AST constructed from it is
\begin{code}
tops(
    apply(
        apply(
            lambda(id[f], 
                lambda(id[x], 
                    apply(id[f], id[x]))),
            g),
        x)
    ::[]
)
\end{code}

A \emph{typing judgement} in \Tcg{} is a pair 
$$term : type$$
where $term$ is a AST subtree and $type$ is term which structure is defined by typing rules. The typing rules are used by \Tcg{} to construct proofs of typing judgements, which are basically trees where the proven judgement is a root and all the edges are \emph{properly} labeled with rules (what ``properly'' means will be explained later). 

A generic typing rule consists of a set of universally quantified \emph{variables}, a list of \emph{premises}, a \emph{conclusion} and a list of \emph{parameters}. In \Tcg{} concrete syntax it is written like this:
\begin{code}
rule apply
  forall(f,e,s,t)
    apply(f,e) : t
  if f : fun(s,t)
  and e : s
\end{code}

In this example, \code{f}, \code{e}, \code{s} and \code{t} are the quantified variables, \code{apply(f,e)} is the conclusion, \code{f : fun(s, t)} and \code{e : s} are the premises. In more familiar logical notation it can be written like this:
\tcgrule{f, e, s, t}{
    \premise{\Gamma |- f : s \rightarrow t}
    \premise{\Gamma |- e : s}
}{\Gamma |- f e : t}{apply}{}

So this rule expresses the typing for application. 

We have written $\Gamma$ in this example to provide the most familiar notation, but in \Tcg{} context is modified by rule applications, so 

rule lambda
forall(x,e,s,t)
lambda(x,e) : fun(s,t)
if e : t
under -( :.1.= x) + [ x : s ]

rule tops
forall(es,ts)
tops(es)
if [branch] es : ts export* ...

environment apply,lambda,tops

----
Polymprphic let:

  rule let_poly
  forall(x,e,e’,s,t)
    let(x,e,e’) : t
  if e : s
  and e’ : t
  under -(:.1.= x) +let_binding[x](<1: [quantify]>)
